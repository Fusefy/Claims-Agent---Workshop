{
  "sbom": {
    "totalComponents": 6,
    "criticalVulnerabilities": 9,
    "highVulnerabilities": 19,
    "mediumVulnerabilities": 17,
    "lowVulnerabilities": 0,
    "components": [
      {
        "name": "Django",
        "version": "2.2.0",
        "license": "unknown",
        "vulnerabilities": 35,
        "severity": "critical",
        "type": "library"
      },
      {
        "name": "PyYAML",
        "version": "5.1",
        "license": "unknown",
        "vulnerabilities": 3,
        "severity": "critical",
        "type": "library"
      },
      {
        "name": "cloud-sql-python-connector",
        "version": "1.12.0",
        "license": "unknown",
        "vulnerabilities": 0,
        "severity": "none",
        "type": "library"
      },
      {
        "name": "fastapi",
        "version": "0.60.0",
        "license": "unknown",
        "vulnerabilities": 1,
        "severity": "high",
        "type": "library"
      },
      {
        "name": "requests",
        "version": "2.19.0",
        "license": "unknown",
        "vulnerabilities": 4,
        "severity": "high",
        "type": "library"
      },
      {
        "name": "uvicorn",
        "version": "0.11.0",
        "license": "unknown",
        "vulnerabilities": 2,
        "severity": "high",
        "type": "library"
      }
    ]
  },
  "vulnerabilityLibrary": [
    {
      "id": "CVE-2019-14234",
      "severity": "critical",
      "component": "Django",
      "description": "An issue was discovered in Django 1.11.x before 1.11.23, 2.1.x before 2.1.11, and 2.2.x before 2.2.4. Due to an error in shallow key transformation, key and index lookups for django.contrib.postgres.fields.JSONField, and key lookups for django.contrib.postgres.fields.HStoreField, were subject to SQL injection. This could, for example, be exploited via crafted use of \"OR 1=1\" in a key or index name to return all records, using a suitably crafted dictionary, with dictionary expansion, as the **kwargs passed to the QuerySet.filter() function.",
      "cvss": 9.8,
      "status": "fixed",
      "discoveredDate": "2019-08-09T13:15:11.777Z"
    },
    {
      "id": "CVE-2019-20477",
      "severity": "critical",
      "component": "PyYAML",
      "description": "PyYAML 5.1 through 5.1.2 has insufficient restrictions on the load and load_all functions because of a class deserialization issue, e.g., Popen is a class in the subprocess module. NOTE: this issue exists because of an incomplete fix for CVE-2017-18342.",
      "cvss": 9.8,
      "status": "fixed",
      "discoveredDate": "2020-02-19T04:15:10.803Z"
    },
    {
      "id": "CVE-2021-32677",
      "severity": "high",
      "component": "fastapi",
      "description": "FastAPI is a web framework for building APIs with Python 3.6+ based on standard Python type hints. FastAPI versions lower than 0.65.2 that used cookies for authentication in path operations that received JSON payloads sent by browsers were vulnerable to a Cross-Site Request Forgery (CSRF) attack. In versions lower than 0.65.2, FastAPI would try to read the request payload as JSON even if the content-type header sent was not set to application/json or a compatible JSON media type (e.g. application/geo+json). A request with a content type of text/plain containing JSON data would be accepted and the JSON data would be extracted. Requests with content type text/plain are exempt from CORS preflights, for being considered Simple requests. The browser will execute them right away including cookies, and the text content could be a JSON string that would be parsed and accepted by the FastAPI application. This is fixed in FastAPI 0.65.2. The request data is now parsed as JSON only if the content-type header is application/json or another JSON compatible media type like application/geo+json. It's best to upgrade to the latest FastAPI, but if updating is not possible then a middleware or a dependency that checks the content-type header and aborts the request if it is not application/json or another JSON compatible content type can act as a mitigating workaround.",
      "cvss": 8.1,
      "status": "fixed",
      "discoveredDate": "2021-06-09T18:15:08.553Z"
    },
    {
      "id": "CVE-2018-18074",
      "severity": "high",
      "component": "requests",
      "description": "The Requests package before 2.20.0 for Python sends an HTTP Authorization header to an http URI upon receiving a same-hostname https-to-http redirect, which makes it easier for remote attackers to discover credentials by sniffing the network.",
      "cvss": 7.5,
      "status": "fixed",
      "discoveredDate": "2018-10-09T17:29:01.897Z"
    },
    {
      "id": "CVE-2020-7694",
      "severity": "high",
      "component": "uvicorn",
      "description": "This affects all versions of package uvicorn. The request logger provided by the package is vulnerable to ASNI escape sequence injection. Whenever any HTTP request is received, the default behaviour of uvicorn is to log its details to either the console or a log file. When attackers request crafted URLs with percent-encoded escape sequences, the logging component will log the URL after it's been processed with urllib.parse.unquote, therefore converting any percent-encoded characters into their single-character equivalent, which can have special meaning in terminal emulators. By requesting URLs with crafted paths, attackers can: * Pollute uvicorn's access logs, therefore jeopardising the integrity of such files. * Use ANSI sequence codes to attempt to interact with the terminal emulator that's displaying the logs (either in real time or from a file).",
      "cvss": 7.5,
      "status": "fixed",
      "discoveredDate": "2020-07-27T12:15:11.87Z"
    }
  ]
}